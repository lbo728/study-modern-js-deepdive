## 46.1 제너레이터란?
- 코드 블록의 실행을 일시 중지 했다가 필요한 시점에 재개할 수 있는 `특수한 함수`

*[제너레이터와 일반 함수의 차이]*
1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
  → 함수의 제어권을 독점하는 것이 아님
2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
  → 함수의 상태를 전달할 수도, 전달 받을 수도 있음
3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
  → 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환

## 46.2 제너레이터 함수의 정의
- 화살표 함수로 정의 불가
- new 연산자와 함께 생성자 함수로 호출 불가

```js
// 제너레이터 함수 선언문
function* genDecFunc() {
  yield 1;
}

// 제너레이터 함수 표현식
const genExpFunc = function* () {
  yield 1;
};

// 제너레이터 메서드
const obj = {
  * genObjMethod() {
    yield 1;
  }
};

// 제너레이터 클래스 메서드
class MyClass {
  * genClsMethod() {
    yield 1;
  }
};
```
## 46.3 제너레이터 객체
- 일반 함수처럼 함수 코드 블록 실행하는 것이 아님
  → 제너레이터 객체 생성하여 반환
- 제너레이터 객체는 이터러블이면서 동시에 이터레이터

```js
// 제너레이터 함수
function* genFunc() {
  yield 1;
  yield 2;
  yield 3;
}

// 제너레이터 함수를 호출 → 제너레이터 객체 반환
const generator = genFunc();

// 이터러블은 Symbol.iterator 메서드를 직접 구현 or 프로토타입 체인을 통해 상속받은 객체
console.log(Symbol.iterator in generator); // true

// 이터레이터는 next 메서드를 갖는다.
console.log('next' in generator); // true
```

## 46.4 제너레이터의 일시 중지와 재개

## 46.5 제너레이터의 활용

  ### 46.5.1 이터러블의 구현

  ### 46.5.2 비동기 처리

## 46.6 async/await

  ### 46.6.1 async 함수

  ### 46.6.2 await 키워드

  ### 46.6.3 에러 처리