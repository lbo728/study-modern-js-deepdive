## 26.1 함수의 구분
- ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.
  → callable / [constructor]( 인스턴스 생성 가능한 함수 객체 )
  <img width="1345" height="279" alt="스크린샷 2025-08-08 142629" src="https://github.com/user-attachments/assets/2fe3360d-a483-45c7-b52d-6362e190712a" />

## 26.2 메서드
- ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미.
  ```js
  const obj = {
    x: 1,
    // foo는 메서드
    foo() { retun this.x; };
    // bar에 바인딩된 함수는 일반 함수
    bar: function() { return this.x; };
  };

  console.log(obj.foo()); // 1
  console.log(obj.bar()); // 1
  ```
- ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor.
  - 따라서 ES6 메서드는 생성자 함수로서 호출 X.
  - prototype 프로퍼티 X, prototype 생성 X.
  - prototype 메서드와 정적 메서드 모두 non-constructor.
  ```js
  new obj.foo(); // → TypeError
  new obj.bar(); // → bar{}

  obj.foo.hasownProperty('prototype); // false
  obj.bar.hasownProperty('prototype); // true

  String / Number / Array
  ```
- ES6 메서드는 자신을 바인딩하는 객체를 가리키는 내부 슬롯[[HomeObject]]을 갖는다. → super 키워드 사용 가능
  ```js
  const base = {
    name: 'Lee',
    sayHi() {
      return `Hi! ${this.name}`;
    }
  };

  // ES6 메서드 → [[HomeObject]] 가짐 → super 사용 가능
  const derived = {
    __proto__: base,
    sayHi() {
      return `${super.sayHi()}. How are you doing?`;
    }
  };

  // ES6 메서드 X → [[HomeObject]] 못 가짐 → super 사용 불가
  const derived = {
    __proto__: base,
    sayHi: function () {
      return `${super.sayHi()}. How are you doing?`; // ERROR
    }
  };

  console.log(derived.sayHi()); // Hi Lee. How are you doing?
  ```

## 26.3 화살표 함수
  ### 26.3.1 화살표 함수 정의
  - 함수 정의 :
    - 함수 선언문으로 정의 X, 함수 표현식으로 정의 O
    - 기존 함수와 호출 방식은 동일
      ``js
      const multiply = (x, y) => x * y;
      multiply(2, 3); // 6
      ```
  - 매개변수 선언 :
    - 매개변수 여러 개 : 소괄호 안에 매개변수 선언
      ```js
      const arrow = (x, y) => { ... };
      ```
    - 매개변수 한 개 : 소괄호 생략 가능
      ```js
      const arrow = x => { ... };
      ```
    - 매개변수 없음 : 소괄호 생략 불가
      ```js
      const arrow = () => { ... };
      ```
  - 함수 몸체 정의 :
    - 하나의 문으로 구성 : 중괄호 생략 가능 but, 표현식이 아닌 문이라면 에러 발생 → 반환 불가해서!
      ```js  
      const power = x => x ** 2;
      power(3); // 9

      const power = x => { return x ** 2 };
      ```
    - 객체 리터럴 반환 시, 소괄호로 감싸준다. → 소괄호 없으면 결과값 undefined
      ```js
      const create = (id, content) => ({ id, content });
      create(1, 'JavaScript');

      const create = (id, content) => { return { id, content }; };
      ```
    - 즉시 실행 함수 가능
      ```js
      const person = (name => ({
        sayHi() { return `Hi! My name is ${name}.`; }
      }))('Lee');

      console.log(person.sayHi()); // Hi! My name is Lee.
      ```
    - 고차 함수에 인수로 전달 가능
      ```js
      // ES5
      [1, 2, 3].map(function (v) {
        return v * 2;
      });

      // ES6
      [1, 2, 3].map(v => v * 2); // → [ 2, 4, 6 ]
      ```

  ### 26.3.2 화살표 함수와 일반 함수의 차이
  1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 이다.
  2. 중복된 매개변수 이름을 선언할 수 없다.
  3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.
  
  ### 26.3.3 this
  1. add 메서드를 호출한 prefixer 객체를 가리키는 this를 일단 회피시킨 후에 콜백 함수 내에서 사용된다.
  2. Array.prototype.map의 두 번째 인수로 add 메서드를 호출한 prefixer 객체를 가리키는 this를 전달한다.
  3. Function.prototype.bind 메서드를 사용하여 add 메서드를 호출한 prefixer 객체를 가리키는 this를 바인딩한다.
  
  - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.
  - 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
  ⇒ lexical this 라고 한다.
  
  ### 26.3.4 super
  - 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.
  ```js
  class Base {
    constructor(name) {
      this.name = name;
    }

    sayHi() {
      return `Hi! ${this.name}`;
    }
  }

  class Derived extends Base {
    // 화살표 함수의 super는 상위 스코프인 constructor의 super를 가리킨다.
    sayHi = () => `${super.sayHi()} how are you doing?`;
  }

  const derived = new Derived('Lee');
  console.log(derived.sayHi()); // Hi! Lee how are you doing?
  ```
  
  ### 26.3.5 arguments
  - 화살표 함수 내부에서 arguments를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.
  ```js
  (function () {
    const foo = () => console.log(arguments);
    // [Arguments] { '0': 1, '1': 2 }

    foo(3, 4);
  }(1, 2));

  const foo = () => console.log(arguments);
  foo(1, 2); // Error
  ```

## 26.4 Rest 파라미터
  ### 26.4.1 기본 문법
  - Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달 받는다.
  - 일반 매개변수와 Rest 파라미터는 함꼐 사용 가능
  - 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당
  ```js
  function bar(param1, param2, ...rest) {
    console.log(param1); // 1
    console.log(param2); // 2
    console.log(rest); // [ 3, 4, 5 ]
  }

  bar(1, 2, 3, 4, 5):
  ```
  - Rest 파라미터는 반드시 마지막 파라미터
  - Rest 파라미터는 단 하나만 선언 가능
  - 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향 x.
  ```js
  function foo (x, y, ...rest) {}
  console.log(foo.length); // 2
  ```
  ### 26.4.2 Rest 파라미터와 arguments 객체
  - *가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있음
    *가변 인자 함수 : 함수를 정의할 때 매개변수 갯수를 확정할 수 없는 함수
  - arguments 객체를 배열로 변환하는 번거로움을 피할 수 있음
  ```js
  function sum(...args) {
    // Rest 파라미터 args에는 배열 [1, 2, 3, 4, 5]가 할당됨
    return args.reduce((pre, cur) => pre + cur, 0);
  }
  console.log(sum(1, 2, 3, 4, 5)); // 15
  ```
## 26.5 매개변수 기본값
- 인수가 전달되지 않은 매개변수 = undefined → 기본값 할당이 필요 (즉, 방어 코드가 필요)
- 매개변수 기본값은
  1. 인수를 전달하지 않은 경우
  2. undefined를 전달한 경우
  에만 유효하다.
```js
function sum(x = 0, y = 0) {
  x = x || 0;
  y = y || 0;
  return x + y;
}
console.log(sum(1, 2)); // 3
console.log(sum(1)); // 1
```