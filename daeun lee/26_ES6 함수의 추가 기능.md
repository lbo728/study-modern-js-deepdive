## 26.1 함수의 구분
- ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.
  → callable / [constructor]( 인스턴스 생성 가능한 함수 객체 )
  <img width="1345" height="279" alt="스크린샷 2025-08-08 142629" src="https://github.com/user-attachments/assets/2fe3360d-a483-45c7-b52d-6362e190712a" />

## 26.2 메서드
- ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미.
  ```js
  const obj = {
    x: 1,
    // foo는 메서드
    foo() { retun this.x; };
    // bar에 바인딩된 함수는 일반 함수
    bar: function() { return this.x; };
  };

  console.log(obj.foo()); // 1
  console.log(obj.bar()); // 1
  ```
- ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor.
  - 따라서 ES6 메서드는 생성자 함수로서 호출 X.
  - prototype 프로퍼티 X, prototype 생성 X.
  - prototype 메서드와 정적 메서드 모두 non-constructor.
  ```js
  new obj.foo(); // → TypeError
  new obj.bar(); // → bar{}

  obj.foo.hasownProperty('prototype); // false
  obj.bar.hasownProperty('prototype); // true

  String / Number / Array
  ```
- ES6 메서드는 자신을 바인딩하는 객체를 가리키는 내부 슬롯[[HomeObject]]을 갖는다. → super 키워드 사용 가능
  ```js
  const base = {
    name: 'Lee',
    sayHi() {
      return `Hi! ${this.name}`;
    }
  };

  // ES6 메서드 → [[HomeObject]] 가짐 → super 사용 가능
  const derived = {
    __proto__: base,
    sayHi() {
      return `${super.sayHi()}. How are you doing?`;
    }
  };

  // ES6 메서드 X → [[HomeObject]] 못 가짐 → super 사용 불가
  const derived = {
    __proto__: base,
    sayHi: function () {
      return `${super.sayHi()}. How are you doing?`; // ERROR
    }
  };

  console.log(derived.sayHi()); // Hi Lee. How are you doing?
  ```

## 26.3 화살표 함수
  ### 26.3.1 화살표 함수 정의
  - 함수 정의 :
    - 함수 선언문으로 정의 X, 함수 표현식으로 정의 O
    - 기존 함수와 호출 방식은 동일
      ``js
      const multiply = (x, y) => x * y;
      multiply(2, 3); // 6
      ```
  - 매개변수 선언 :
    - 매개변수 여러 개 : 소괄호 안에 매개변수 선언
      ```js
      const arrow = (x, y) => { ... };
      ```
    - 매개변수 한 개 : 소괄호 생략 가능
      ```js
      const arrow = x => { ... };
      ```
    - 매개변수 없음 : 소괄호 생략 불가
      ```js
      const arrow = () => { ... };
      ```
  - 함수 몸체 정의 :
    - 하나의 문으로 구성 : 중괄호 생략 가능 but, 표현식이 아닌 문이라면 에러 발생 → 반환 불가해서!
      ```js  
      const power = x => x ** 2;
      power(3); // 9

      const power = x => { return x ** 2 };
      ```
    - 객체 리터럴 반환 시, 소괄호로 감싸준다. → 소괄호 없으면 결과값 undefined
      ```js
      const create = (id, content) => ({ id, content });
      create(1, 'JavaScript');

      const create = (id, content) => { return { id, content }; };
      ```
    - 즉시 실행 함수 가능
      ```js
      const person = (name => ({
        sayHi() { return `Hi! My name is ${name}.`; }
      }))('Lee');

      console.log(person.sayHi()); // Hi! My name is Lee.
      ```
    - 고차 함수에 인수로 전달 가능
      ```js
      // ES5
      [1, 2, 3].map(function (v) {
        return v * 2;
      });

      // ES6
      [1, 2, 3].map(v => v * 2); // → [ 2, 4, 6 ]
      ```

  ### 26.3.2 화살표 함수와 일반 함수의 차이
  1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 이다.
  2. 중복된 매개변수 이름을 선언할 수 없다.
  3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.
  
  ### 26.3.3 this
  1. add 메서드를 호출한 prefixer 객체를 가리키는 this를 일단 회피시킨 후에 콜백 함수 내에서 사용된다.
  2. Array.prototype.map의 두 번째 인수로 add 메서드를 호출한 prefixer 객체를 가리키는 this를 전달한다.
  3. Function.prototype.bind 메서드를 사용하여 add 메서드를 호출한 prefixer 객체를 가리키는 this를 바인딩한다.
  
  - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.
  - 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
  ⇒ lexical this 라고 한다.
  
  ### 26.3.4 super
  
  ### 26.3.5 arguments

## 26.4 Rest 파라미터

### 26.4.1 기본 문법

### 26.4.2 Rest 파라미터와 arguments 객체체

## 26.5 매개변수 기본값값
