## 40.1 이벤트 드리븐 프로그래밍
- 이벤트 중심으로 제어하는 프로그래밍 방식
- 이벤트 핸들러를 통해 사용자와 애플리케이션의 상호작용

- 이벤트 핸들러(Event Handler) : 이벤트가 발생했을 때 호출될 함수
  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <button>Click Me!</button>
    <script>
      const $button = document.querySelector('button');

      // 사용자가 버튼을 클릭하면 함수를 호출하도록 요청
      $button.onClick = () => { alert('button click!'); };
    </script>
  </body>
  </html>
  ```

  <img width="800" height="600" alt="image" src="https://github.com/user-attachments/assets/cff0dfc1-5716-4e15-b328-0beac6c552b6" />

## 40.2 이벤트 타입
  ### 40.2.1 마우스 이벤트
  - click : 클릭
  - dblclick : 더블 클릭
  - mousedown : 눌렀을 때
  - mouseup : 누르던걸 뗐을 때
  - mousemove : 커서 움직였을 때
  - mouseenter : HTML 요소 안으로 이동했을 때 (버블링 X)
  - mouseover : HTML 요소 안으로 이동했을 때 (버블링 O)
  - mouseleave : HTML 요소 밖으로 이동했을 때 (버블링 X)
  - mouseout : HTML 요소 밖으로 이동했을 때 (버블링 O)

  ### 40.2.2 키보드 이벤트
  - keydown : 모든 키를 눌렀을 때
  - keypress : 문자 키를 눌렀을 때
  - keyup : 누르고 있던 키를 놓았을 때

  ### 40.2.3 포커스 이벤트
  - focus : HTML 요소가 포커스를 받았을 때 (버블링 X)
  - blur : HTML 요소가 포커스를 잃었을 때 (버블링 X)
  - focusin : HTML 요소가 포커스를 받았을 때 (버블링 O)
  - focusout : HTML 요소가 포커스를 잃었을 때 (버블링 O)

  ### 40.2.4 폼 이벤트
  - submit : 
    1. form 요소 내의 input, select 입력 필드에서 엔터 키를 눌렀을 때
    2. form 요소 내의 submit 버튼을 클릭했을 때
  - reset : form 요소 내의 reset 버튼을 클릭했을 때

  ### 40.2.5 값 변경 이벤트
  - input : input, select, textarea 요소의 값이 입력되었을 때
  - change : input, select, textarea 요소의 값이 변경되었을 때
  - readystatechange : HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티 값
                       ('loading', 'interactive', 'complete')이 변경될 때

 ### 40.2.6 DOM 뮤테이션 이벤트
  - DOMContentLoaded : HTML 문서의 로드와 파싱이 완료되어 *DOM 생성이 완료* 되었을 때

  ### 40.2.7 뷰 이벤트
  - resize : 브라우저 윈도우의 크기를 리사으지할 때 연속적으로 발생
  - scroll : 웹페이지 또는 HTML 요소를 스크롤할 때 연속적으로 발생

  ### 40.2.8 리소스 이벤트
  - load : DOMContentLoaded 이벤트 발생 후, 모든 리소스의 로딩이 완료 되었을 때
  - unload : 리소스 언로드될 때 (주로 새로운 웹페이지 요청 시)
  - abort : 리소스 로딩이 중단 되었을 때
  - error : 리소스 로딩이 실패했을 때

## 40.3 이벤트 핸들러 등록
```html
<!DOCTYPE html>
<html>
<body>
  // attribute
  <button v-on:click="handleClick($event)">Click Me!</button>
  <script>
    const $button = document.querySelector('button');

    $button.onClick = function () {
      console.log('[Event Handler Property] button click');
    }

    $button.addEventListener(() {
      console.log('[addEventListener] button click');
    });
  </script>
</body>
</html>
```

  ### 40.3.1 이벤트 핸들러 어트리뷰트 방식
  ```js
  // Vue.js
  <button v-on:click="handleClick($event)">Save</button>
  ```

  ### 40.3.2 이벤트 핸들러 프로퍼티 방식
  ```js
  // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
  $button.onclick = function() {
    console.log('button click');
  };
  ```

  ### 40.3.3 addEventListener 메서드 방식
  ```js
  EventTarget.addEventListener('eventType', functionName [, useCapture]);
  ```
  - capture 사용 여부
    - true : capturing
    - false : bubbling (default)

## 40.4 이벤트 핸들러 제거
- addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않는다.
  ```js
  $button.addEventListener('click', handleClick);

  $button.removeEventListener('click', handleClick); // 성공
  $button.removeEventListener('click', handleClick, true); // 실패
  ```

  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <button>Click Me!</button>
    <script>
      const $button = document.querySelector('button');

      const handleClick = () => console.log('button click');

      // 프로퍼티 방식으로 등록
      $button.onClick = handleClick;

      // removeEventListener로 제거 불가능
      $button.removeEventListener();

      // 이벤트 핸들러 제거
      $button.onClick = null;
    </script>
  </body>
  </html>
  ```

## 40.5 이벤트 객체
- 생성된 이벤트 객체는 이벤트 핸들러의 *첫 번째 인수로 전달*
  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <p>click</p>
    <em class="message"></em>
    <script>
      const $message = document.querySelector('message');

      // 클릭 이벤트에 의해 생성된 이벤트 객체
      function show
    </script>
  </body>
  </html>
  ```

  ### 40.5.1 이벤트 객체의 상속 구조

  ### 40.5.2 이벤트 객체의 공통 프로퍼티
  - type : 이벤트 타입
  - target : 이벤트 발생시킨 DOM 요소
  - currentTarget : 이벤트 핸들러가 바인딩된 DOM 요소
  - eventPhase : 이벤트 전파 단계
    - 0 : 이벤트 없음
    - 1 : 캡처링 단계
    - 2 : 타깃 단계
    - 3 : 버블링 단계
  - bubbles : 이벤트를 버블링으로 전파하는지 여부
    - 포커스 이벤트 : focus / blur
    - 리소스 이벤트 : load / unload / abort / error
    - 마우스 이벤트 : mouseenter / mouseleave
  - cancelable : 이벤트의 기본 동작을 취소할 수 있는지 여부 (preventDefault 메서드를 호출)
    - 포커스 이벤트 : focus / blur
    - 리소스 이벤트 : load / unload / abort / error
    - 마우스 이벤트 : mouseenter / mouseleave
  - defaultPrevented : 이벤트를 취소했는지 여부 (preventDefault 메서드를 호출)
  - isTrusted : 사용자의 행위에 의해 발생한 이벤트인지 여부
  - timeStamp : 이벤트가 발생한 시각

  ### 40.5.3 마우스 정보 취득
  - 마우스 포인터의 좌표 정보를 나타내는 프로퍼티
    - screenX / screenY
    - clientX / clientY
    - pageX / pageY
    - offsetX / offsetY
  - 버튼 정보를 나타냐는 프로퍼티
    - altKey
    - ctrlKey
    - shiftKey
    - button

  ### 40.5.4 키보드 정보 취득
  - altKey, ctrlKey, shiftKey, metaKey, key, keyCode 같은 고유의 프로퍼티를 가짐
  - input 요소의 입력 필드에 한글 입력 후 엔터 키 누르면
    → keyup 이벤트 핸들러가 두 번 호출
    → 해결 방법 : keyup 대신 keydown 이벤트를 캐치

## 40.6 이벤트 전파
- 생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파
  1. 캡처링 단계 : 이벤트가 상위 요소 → 히위 요소 방향으로 전파
  2. 타깃 단계 : 이벤트가 이벤트 타깃에 도달
  3. 버블링 단계 : 이벤트가 하위 요소 → 상위 요소 방향으로 전파

  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <ul id="fruits">
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      const $fruits = document.getElementById('fruits');
      const $banana = document.getElementById('banana');

      // #fruits 요소의 하위 요소인 li 요소를 클릭한 경우
      // 캡처링 단계의 이벤트 캐치
      $fruits.addEventListener('click', e => {
        console.log(`이벤트 단계: ${e.eventPhase}`);
        console.log(`이벤트 타깃: ${e.target}`);
        console.log(`currentTarget: ${e.currentTarget}`);
      }, true);

      // 타깃 단계의 이벤트 캐치
      $banana.addEventListener('click', e => {
        console.log(`이벤트 단계: ${e.eventPhase}`);
        console.log(`이벤트 타깃: ${e.target}`);
        console.log(`currentTarget: ${e.currentTarget}`);
      });

      // 버블링 단계의 이벤트 캐치
      $fruits.addEventListener('click', e => {
        console.log(`이벤트 단계: ${e.eventPhase}`);
        console.log(`이벤트 타깃: ${e.target}`);
        console.log(`currentTarget: ${e.currentTarget}`);
      });
    </script>
  </body>
  </html>
  ```

## 40.7 이벤트 위임
- 여러 개의 하위 DOM  요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법
- 상위 DOM 요소에 이벤트 핸들러를 등록하면 여러 개의 하위 DOM 요소에 이벤트 핸들러 등록할 필요 없음
  ```html
  <!DOCTYPE html>
  <html>
  <head>
    <style>
      #fruits {

      }
    </style>
  </head>
  <body>
    <nav>
      <ul id="fruits">
        <li id="apple" class="active">Apple</li>
        <li id="banana">Banana</li>
        <li id="orange">Orange</li>
      </ul>
    </nav>
    <div>선택된 내비게이션 아이템 : <em class="message">apple</em></div>
    <script>
      const $fruits = document.getElementById('fruits');
      const $message = document.querySelector('.message');

      function activate({ target }) {
        if (!target.matches('#fruits > li')) return;

        [...$fruits.children].forEach($fruit => {
          $fruit.classList.toggle('active', $fruit === target);
          $message.textContent = target.id;
        });
      }

      // 이벤트 위임 : 상위 요소(ul#fruits)는 하위 요소의 이벤트를 캐치할 수 없다.
      $fruits.onclick = activate;
    </script>
  </body>
  </html>
  ```

## 40.8 DOM 요소의 기본 동작 조작

  ### 40.8.1 DOM 요소의 기본 동작 중단
  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <a href="https://www.google.com">GO!</a>
      <input type="checkbox">
      <script>
        document.querySelector('a').onclick = e => {
          e.preventDefault();
        };

         document.querySelector('input[type=checkbox]').onclick = e => {
          e.preventDefault();
        };
      </script>
    </body>
  </html>
  ```

  ### 40.8.2 이벤트 전파 방지
  - 이벤트 객체의 stopPropagation 메서드는 이벤트 전파를 중지
  - 하위 DOM 요소의 이벤트를 개별적으로 처리하기 위해 이벤트 전파를 중지

## 40.9 이벤트 핸들러 내부의 this
  ### 40.9.1 이벤트 핸들러 어트리뷰트 방식
  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <button onclick="handleClick()">Save</button>
    <script>
      function handleClick() {
        console.log(this); // window
      }
    </script>
  </body>
  </html>
  ```

  ### 40.9.2 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식
  - 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.
  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <button class="button1">0</button>
    <button class="button2">0</button>
    <script>
      const $button1 = document.querySelector('.button1');
      const $button2 = document.querySelector('.button2');

      $button1.onclick = function (e) {
        console.log(this); // $button1
        console.log(e.currentTarget); // $button1
        console.log(this === e.currentTarget); // true

        ++this.textContent;
      };

      $button2.addEventListener('click', function (e) {
        console.log(this); // $button2
        console.log(e.currentTarget); // $button2
        console.log(this === e.currentTarget); // true

        ++this.textContent;
      });
    </script>
  </body>
  </html>
  ```

## 40.10 이벤트 핸들러에 인수 전달
- 어트리뷰트 방식 : 함수 호출문 사용 가능 → 인수 전달 가능
- 프로퍼티 방식 & addEventListener 메서드 방식 : 함수 자체를 등록 → 인수 전달 불가능
  - 방법 : 
  1. 이벤트 핸들러 내부에서 함수를 호출하면서 인수 전달
  2. 이벤트 핸들러를 반환하는 함수를 호출하면서 인수 전달

## 40.11 커스텀 이벤트
- 개발자의 의도로 생성된 이벤트

  ### 40.11.1 커스텀 이벤트 생성
  - 생성자 함수로 이벤트 타입의 커스텀 이벤트 객체를 생성
  ```js
  const mouseEvent = new MouseEvent('click', {
    clientX: 50,
    clientY: 100
  });

  console.log(mouseEvent.clientX); // 50
  console.log(mouseEvent.clientY); // 100

  const keyboardEvent = new KeyboardEvent('keyup', { key: 'Enter' });
  console.log(keyboardEvent.key); // Enter
  ```

  ### 40.11.2 커스텀 이벤트 디스패치
  - dispatch는 일을 '처리하다’라는 뜻
  - 일반적인 이벤트 핸들러는 비동기, dispatchEvent 메서드는 동기
  - 이벤트를 강제로 발생 ex) 클릭하지 않았지만 동작
  - addEventListener가 선행되어야 함
