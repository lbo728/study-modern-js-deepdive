## 11.1 원시 값
  ### 11.1.1 변경 불가능한 값
  - 변경이 불가능한 *값* (readonly)

  ```js
  // [예제 11-01]
  const xx = {}; // const = 재할당 금지된 변수
  xx.a = 1; // 선언한 변수에 할당한 객체는 변경할 수 있음
  console.log(xx); // {a: 1}
  ```

  - `값의 불변성`
    - 변수 값 변경하기 위해
      1. 원시 값을 재할당
      2. 새로운 메모리 공간 확보
      3. 재할당한 값 저장
      4. 변수가 참조하던 메모리 곤간 주소 변경
  **불변성을 갖는 원시 값을 할당한 변수 → 재할당 이외의 값 변경 불가**

  ### 11.1.2 문자열과 불변성
  ```js
  // [예제 11-03]
  var str = 'Hello';
  str = 'World';
  ```
  - 'Hello', 'World' 모두 메모리에 존재
  - 식별자 string은 문자열 'Hello'를 가리키고 있다가
    문자열 'World'를 가리키도록 변경되었을 뿐!

  - `유사 배열 객체`
  ```js
  // [예제 11-04, 11-05]
  var str = 'string';

  str[0] = 'S'; // 동작하지 않음 → readonly

  console.log(str); // string
  console.log(str[0]); // s

  console.log(str.length); // 6
  console.log(str.toUpperCase()); // STRING
  ```

  ### 11.1.3 값에 의한 전달
  ```js
  var score = 80;
  var copy = score;

   console.log(score); // 80
   console.log(copy); // 80

   score = 100;

   console.log(score); // 100
   console.log(copy); // 80
  ```
  - `값에 의한 전달`
    - 할당 되는 변수(score) ---(원시 값 복사)--→ 할당 받는 변수(copy)
    - score 값 80 != copy 값 80 → 다른 메모리 공간에 저장된 *별개의 값*
      → score 값을 변경해도 copy 값에는 어떠한 영향도 X
    - 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 *메모리 주소*가 전달
      but, 전달된 메모리 주소를 통해 메모리 공간에 접근 → 값을 참조할 수 있음

## 11.2 객체
- property 갯수 X, 값에 제약 X
- 동적으로 추가, 삭제
⇒ 메모리 공간 크기 확보 불가


  ### 11.2.1 변경 가능한 값
  - 객체(참조) 타입의 값
  - 참조 값은 생성된 객체가 저장된 메모리 공간의 주소
  - 원시 값과 다르게 객체는 변경 가능

  ```js
  // [예제 11-13]
  var person = {
    name: 'Lee'
  };

  person.name = 'Kim';
  person.address = 'Seoul';

  console.log(person); // {name: "Kim", address: "Seoul"}
  ```
  - 객체를 할당한 변수는 재할당 없이 직접 변경할 수 있음
    1. 프로퍼티를 동적으로 추가 가능
    2. 프로퍼티 값을 갱신
    3. 프로퍼티 자체를 삭제도 가능

  - 단점 : 여러 개의 식별자가 하나의 객체를 공유

  - 얕은 복사 vs 깊은 복사
    ```js
    const object = { x: { y: 1 } };

    // 얕은 복사
    const shallowCopy = { ...object };
    console.log(shallowCopy === object); // false
    console.log(shallowCopy.x === object.x); // true

    // lodash의 cloneDeep을 사용한 깊은 복사
    const _ = require('lodash');

    // 깊은 복사
    const deepCopy = _.cloneDeep(object);
    console.log(deepCopy === object); // false
    console.log(deepCopy.x === object.x); // false → 새로 복사됨
    ```
    - 얕은 복사는 같은 참조를 공유하여 값을 변경하면 원본에 영향을 주는 반면,
    - 깊은 복사는 새로 복사되어 값이 변경되어도 원본은 그대로 유지

  ### 11.2.2 참조에 의한 전달
  - 두 개의 식별자가 하나의 객체를 공유
  - 참조 값이 복사되어 전달
  - 메모리 주소는 다르지만, 동일한 참조 값

  ```js
  // [예제 11-16]
  var person = {
    name: 'Lee'
  };

  var copy = person; // 얕은 복사
  ```
  
  - `값에 의한 전달 vs 참조에 의한 전달`
    - 공통점 : 식별자가 기억하는 메모리 공간(변수)에 저장되어 있는 값을 복사
    - 차이점 : 식별자가 기억하는 메모리 공간(변수)에 저장되어 있는 값이
              **원시 값** 인지 **참조 값** 인지 의 차이