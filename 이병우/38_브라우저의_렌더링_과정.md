# 38장 브라우저의 렌더링 과정
구글의 `V8` 자바스크립트 엔진으로 빌드된 **자바스크립트 런타임 환경**(runtime environment)인 `Node.js의` 등장으로 자바스크립트는 웹 브라우저를 벗어나 `서버 사이드` 애플리케이션 개발에서도 사용할 수 있는 범용 개발 언어가 되었다. 
- **하지만 자바스크립트가 가장 많이 사용되는 분야는 역시 웹 브라우저 환경에서 동작하는 웹페이지/애플리케이션의 `클라이언트 사이드`다.**

대부분의 프로그래밍 언어는 `운영체제`(Operating System, OS)나 `가상 머신`(Virtual Machine, VM) 위에서 실행되지만 **웹 애플리케이션의 클라이언트 사이드 `자바스크립트`는 브라우저에서 `HTML`, `CSS와` 함께 실행된다.**

### 브라우저가 HTML, CSS, 자바스크립트로 작성된 텍스트 문서를 파싱하여 브라우저에 렌더링하는 과정
#### 파싱(parsing)
`파싱`(구문 분석, syntax analysis)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 `토큰`(token)으로 `분해`(어휘 분석, exical analysis)하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 `파스 트리`(parse tree/syntax tree)를 생성하는 일련의 과정을 말한다. 

<br>

#### 렌더링(rendering)
렌더링은 `HTML`, `CSS`, `자바스크립트`로 작성된 문서를 `파싱`하여 **브라우저에 시각적으로 출력하는 것을 말한다.**

<br>

### 브라우저의 렌더링 과정(critical rendering path) 간략 표현

<img width="1200" height="2426" alt="38_1_브라우저의_렌더링_과정" src="https://github.com/user-attachments/assets/5f018622-7f69-49fb-be34-3fd47dd4db89" />


1. 브라우저는 `HTML`, `CSS`, `자바스크립트`, 이미지, 폰트 파일 등 **렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.**
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 `HTML`과 `CSS`를 파싱하여 `DOM`과 `CSSOM`을 생성하고 이들을 결합하여 `렌더 트리`를 생성한다.
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 `AST`(Abstract Syntax Tree)를 생성하고 `바이트코드`로 변환하여 실행한다. 이때 자바스크립트는 `DOM API`를 통해 `DOM`이나 `CSSOM`을 변경할 수 있다. **변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.**
4. `렌더 트리`를 기반으로 **HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 `페인팅`한다.**

<br>

## 38.1 요청과 응답

브라우저의 핵심 기능은 필요한 리소스(HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버에 `요청`(request)하고 서버로부터 `응답`(response) 받아 **브라우저에 시각적으로 렌더링하는 것이다.**
- 즉, **렌더링에 필요한 리소스는 모두 서버에 존재하므로 필요한 리소스를 서버에 요청하고 서버가 응답한 리소스를 파싱하여 렌더링하는 것이다.**

<br>

### URI
서버에 요청을 전송하기 위해 브라우저는 `주소창`을 제공한다.
브라우저의 주소창에 URL을 입력하고 엔터 키를 누르면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에게 요청을 전송한다.


<img width="1200" height="1079" alt="38_2_URI" src="https://github.com/user-attachments/assets/754b7276-3529-4695-8316-dab6d2c451e4" />

<br>


#### 암묵적인 index.html 요청
브라우저의 주소창에 `https://poiemaweb.com`을 입력하고 엔터 키를 누르면 루트 요청(`/`, `스킴`과 `호스트`만으로 구성된 URI에 의한 요청)이 poiemaweb.com 서버로 전송된다. 
- 루트 요청에는 명확히 리소스를 요청하는 내용이 없지만 일반적으로 **서버는 루트 요청에 대해 암묵적으로 `index.html`을 응답하도록 기본 설정되어있다.**
- `https:poiemaweb.com` === `https://poiemaweb.com/index.html`
- 따라서, 서버는 루트 요청에 대해 서버의 루트 폴더에 존재하는 정적 파일 index.html을 클라이언트(브라우저)로 응답한다.
<br>

#### index.html이 아닌 다다른 정적 파일을 서버에 요청하려면
브라우저의 주소창에 https://poiemaweb.com/assets/data/daya.json과 같이 요청할 정적 파일의 경로(서버의 루트 폴더 기준)와 파일 이름을 URI의 호스트 뒤의 패스(path)에 기술하여 서버에 요청한다. 
- 서버는 루트 폴더의 assets/data 폴더 내에 있는 정적 파일 data.json을 응답할 것이다.


<br>

#### Network 패널에서 요청하지 않은 리소스들이 응답되는 이유
브라우저의 렌더링 엔진이 HTML(index.html)을 파싱하는 도중에 외부 리소스를 로드하는 태그, 즉 CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 img 태그, 자바스크립트를 로드하는 script 태그 등을 만나면 **HTML의 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청하기 때문이다.**


<br>

## 38.2 HTTP 1.1과 HTTP 2.0

HTTP(Hyper Text Transfer Protocol)은 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다. 
> _1989년, HTML, URL과 함께 팀 버너스 리 경(Sir tim Berners-Lee)이 고안한 HTTP는 1991년 최초로 문서화되었고 1996년 HTTP/1.0, 1999년 HTTP/1.1, 2015년 HTTP/2가 발표되었다._

### HTTP/1.1
**HTTP/1.1은 기본적으로 `커넥션`(connection) 당 하나의 요청과 응답만 처리한다.**
- 즉, 여러 개의 요청을 한 번에 전송할 수 없고 응답 또한 마찬가지다.

#### 단점
HTML 문서 내에 포함된 여러 개의 리소스 요청(CSS 파일을 로드하는 link 태그, 자바스크립트를 로드하는 script 태그 등)이 개별적으로 전송되고 응답 또한 개별적으로 전송된다.
→ **리소스의 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례하여 응답 시간도 증가하는 단점이 있다.**

<img height="800" alt="38_5_HTTP:2" src="https://github.com/user-attachments/assets/a99a3380-6154-4410-834d-2759945f874e" />


<br>

### HTTP/2

HTTP/2는 커넥션당 여러개의 요청과 응답, 즉 다중 요청/응답이 가능하다. 
따라서 HTTP/2.0은 여러 리소스의 동시 전송이 가능하므로 HTTP/1.1에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 알려져 있다.

<img  height="800" alt="38_4_HTTP:1 1" src="https://github.com/user-attachments/assets/663574af-c00a-44aa-adbd-663bbf57aa72" />



<br>

## 38.3 HTML 파싱과 DOM 생성

브라우저의 요청에 의해 서버가 응답한 `HTML 문서`는 **문자열로 이루어진 순수한 텍스트다.**
- **순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야 한다.**

```html
<!-- [예제 38-01] !-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script src="app.js"></script>
  </body>
</html>
```

### 브라우저의 렌더링 엔진이 HTML 문서를 파싱하여 DOM(Document Object Model)을 생성하는 과정
위 HTML 예제를 파싱하여 `DOM`을 생성하는 과정은 다음과 같다.
- `DOM`은 HTML 문서를 `파싱`한 결과물이다.

<img width="1200"  alt="38_6_HTML_파싱과_DOM_생성" src="https://github.com/user-attachments/assets/88bd5f68-ac76-45ce-aff6-7512f4498d43" />

#### 요약 버전)
1. 서버는 요청받은 HTML 파일을 읽고 `바이트`(2진수) 형태로 **응답한다.**
2. 브라우저는 응답받은 `바이트`를 지정된 `인코딩`(예: UTF-8)으로 **문자열로 변환한다.**
3. 문자열 HTML을 `토큰`(token)으로 분해한다.
4. 토큰을 바탕으로 `노드`(node)를 생성한다.
5. 노드들을 트리 구조로 연결하여 `DOM`(Document Object Model)을 만든다.

———

#### 긴 버전)

1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다. 이때 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음, 메모리에 저장된 `바이트`(2진수)를 인터넷을 경유하며 응답한다.
2. 브라우저는 서버가 응답한 HTML 문서를 `바이트`(2진수) 형태로 응답받는다. 그리고 응답된 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식(eg., UTF-8)을 기준으로 문자열로 변환된다.
   - 참고로 meta 태그와 charset 어트리뷰트에 선언된 인코딩 방식(e.g., UTF-8)은 content-type: text/html; charset=utf-8과 같이 응답 헤더(response header)에 담겨 응답된다. 브라우저는 이를 확인하고 문자열로 변환한다.
3. 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 `토큰`(token)들로 분해한다.
4. 각 토큰들을 객체로 변환하여 `노드`(node)들을 생성한다. 토큰의 내용에 따라 문서 `노드`, `요소 노드`, `어트리뷰트 노드`, `텍스트 노드`가 생성된다. (노드는 이후 DOM을 구성하는 기본 요소가 된다.)
5. HTML 문서는 HTML 요소들의 집합으로 이루어지며 **HTML 요소는 중첩 관계를 갖는다.**
   - 즉, HTML 요소의 콘텐츠 영역(시작 태그와 종료 태그 사이)에는 텍스트뿐만 아니라 다른 HTML 요소도 포함될 수 있다.
   - 이때 HTML 요소 간에는 중첩 관계에 의해 **부자 관계가 형성된다.**
   - 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 `트리 자료구조`로 구성한다. 이 노드들로 구성된 트리 자료구조를 `DOM`(Document Object Model)이라 부른다.
  
  

<br>

## 38.4 CSS 파싱과 CSSOM 생성

### CSSOM 생성 과정

#### 1. HTML 파싱

```html
<!-- [예제 38-02] !-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
...
```

#### 2. CSS 파싱

```css
<!-- [예제 38-03] !-->
body {
  font-size: 18px;
}

ul {
  list-style-type: none;
}
```

#### 3. CSSOM 생성

<img width="800"  alt="38_7_CSSOM_생성" src="https://github.com/user-attachments/assets/5279e694-85c5-4797-862f-767551348f8e" />


1. 렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나간다.
2. 렌더링 엔진은 DOM을 생성해 나가다가 CSS를 로드하는 `link 태그`나 `style 태그`를 만나면 DOM 생성을 일시 중단한다.
3. `link 태그`의 `href 어트리뷰트`에 지정된 CSS 파일을 서버에 요청하여 로드한 `CSS 파일`이나 `style 태그` 내의 **CSS를 HTML과 동일한 파싱 과정(바이트 → 문자 → 토큰 → 노드 → CSSOM)을 거치며 해석하여 `CSSOM`(CSS Object Model)을 생성한다.**
4. `CSS 파싱`을 완료하면 **HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.**




<br>

## 38.5 렌더 트리 생성

렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 `CSSOM`을 생성한다. 그리고 **DOM과 CSSOM은 렌더링을 위한 `렌더 트리`(render tree)로 결합된다.**
- `렌더 트리`: 렌더링을 위한 트리 구조의 자료구조
- 따라서 브라우저 화면에 렌더링되지 않는 노드(e.g., meta 태그, script 태그 등)와 CSS에 의해 비표시(e.g., display: none)되는 노드들은 포함되지 않는다.
- 즉, **렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다.**

<img width="800"  alt="38_8_렌더_트리_생성" src="https://github.com/user-attachments/assets/a064c006-b9b3-4ee2-bd2c-0435b8b7b57e" />


### 렌더 트리는 페인팅 처리에 입력된다.
이후 완성된 `렌더 트리`는 **각 HTML 요소의 레이아웃(위치와 크기)을 계산하는 데 사용되며 브라우저 화면에 픽셀을 렌더링하는 `페인팅`(painting) 처리에 입력된다.**

<img width="800" alt="38_9_렌더_트리와_레이아웃_페인트" src="https://github.com/user-attachments/assets/d417da84-1f8f-4e7d-a535-77861013403c" />

<br>

### 브라우저의 렌더링 과정이 반복해서 실행되는 경우
다음과 같은 경우 반복해서 `레이아웃 계산`과 `페인팅`이 실행된다.

- 자바스크립트에 의한 노드 추가 또는 삭제
- 브라우저 창의 리사징에 의한 `뷰포트`(viewport) 크기 변경
- HTML 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경 (`리플로우`)

[***참고: 리플로우(Reflow) vs 리페인트(Repaint)***](#리플로우reflow-vs-리페인트repaint)

<br>

### ⚠️ 주의: 리렌더링
**레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 비용이 많이 드는, 즉 성능에 악영향을 주는 작업이다.** (가급적 빈번하게 발생하지 않도록 주의)




<br>

## 38.6 자바스크립트 파싱과 실행
CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 `script 태그`나 자바스크립트 코드를 콘텐츠로 담은 `script 태그`를 만나면 DOM 생성을 일시 중단한다.
- 그리고 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 script 태그 내의 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘긴다.
- 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.

### 자바스크립트 엔진의 역할
자바스크립트 파싱과 실행은 브라우저의 렌더링 엔진이 아닌 `자바스크립트 엔진`이 처리한다. 
- `자바스크립트 엔진`은 **자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 `저수준 언어`(low-level language)로 변환하고 실행하는 역할**을 한다.
- 자바스크립트 엔진의 종류: 모두 ECMAScript 사양을 준수한다.
  - V8(구글 크롬, Node.js)
  - SpiderMonkey(파이어폭스)
  - JavaScriptCore(사파리)
 
### AST 생성(추상적 구문 트리, Apstract Syntax Tree)
렌더링 엔진으로부터 제어권을 넘겨받은 `자바스크립트 엔진`은 **자바스크립트 코드를 파싱**하기 시작한다. 
- 렌더링 엔진이 HTML과 CSS를 파싱하여 `DOM`과 `CSSOM`을 생성하듯이, 자바스크립트 엔진은 **자바스크립트를 해석하여 `AST`(추상적 구문 트리, Abstract Syntax Tree)를 생성**한다. 
- 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 `중간 코드`(intermediate code)인 `바이트코드`를 생성하여 실행한다.


<img width="1200"  alt="38_10_자바스크립트_파싱과_실행" src="https://github.com/user-attachments/assets/f9ca7cd8-d6c8-4ef6-97b9-148ae3540320" />

### 토크나이징(tokennizing)
단순한 문자열인 자바스크립트 코드를 `어휘 분석`(lexical analysis)하여 문법적 의미를 갖는 코드의 최소 단위인 `토큰`(token)들로 분해한다.
- 이 과정을 `렉싱`(lexing)이라고 부르기도 하지만, `토크나이징`과 미묘한 차이가 있다.

<br>

### 파싱(Parsing)
**토큰들의 집합을 `구문 분석`(syntactic analysis)하여 `AST`(추상적 구문 트리, Abstract Syntax Tree)를 생성한다.**
- `AST`: 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조
  - `인터프리터`나 `컴파일러`만이 사용하는 것이 아니라, TypeScript, Babel, Prettier 같은 `트랜스파일러`(transpiler)를 구현할 수도 있다.
 
<br>

### 바이트코드 생성과 실행
파싱의 결과물로서 생성된 `AST`는 `인터프리터`가 실행할 수 있는 중간 코드인 `바이트코드`로 변환되고 인터프리터에 의해 실행된다.

<br>

## 38.7 리플로우와 리페인트
만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 `DOM API`가 사용된 경우 `DOM`이나 `CSSOM`이 변경된다. 
- **이때 변경된 DOM과 CSSOM 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. **
- → 이를 `리플로우`(reflow), `리페인트`(repaint)라고 한다.
- `리플로우`와 `리페인트`가 **반드시 순차적으로 동시에 실행되는 것은 아니다**.
  -  **레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행된다.**
<img width="800"  alt="38_12_DOM_API_에의한_리플로우_리페인트" src="https://github.com/user-attachments/assets/f63d8840-4a8c-4542-9414-063e00e6d518" />


### 리플로우
**레이아웃 계산을 다시 하는 것**
- 노트 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 실행된다.

<br>


### 리페인트
재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것


<br>


### 리플로우(Reflow) vs 리페인트(Repaint)

| 구분 | 리플로우 (Reflow / Layout) | 리페인트 (Repaint / Paint) |
| --- | --- | --- |
| **정의** | DOM 요소의 **크기와 위치(레이아웃)를 다시 계산**하는 과정 | 레이아웃 계산된 요소를 **화면에 다시 그리는 과정** |
| **트리거(발생 조건)** | - DOM 구조 변경 (추가/삭제)- 윈도우 리사이즈- `width`, `height`, `margin`, `padding`, `border`, `position`, `display` 등 레이아웃에 영향을 주는 속성 변경 | - `color`, `background-color`, `visibility` 등 **위치·크기에는 영향 없지만 시각적 스타일만 바뀌는 경우** |
| **영향 범위** | 부분적으로만 일어나도 **연쇄적으로 전체 레이아웃에 영향** 가능 | 해당 요소나 하위 요소만 다시 그림 |
| **비용(성능)** | **고비용** → 문서 전체에 영향을 줄 수 있음 | 비교적 **저비용** |
| **최적화 방법** | - DOM 조작 최소화- 스타일 변경 모아서 처리- `transform`, `opacity` 활용 | - GPU 가속(`transform`, `opacity`) 활용으로 레이어 단위 처리 |

<br>


## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고, **직렬적으로 파싱을 수행한다.**

<img width="800"  alt="38_13_직렬적_파싱" src="https://github.com/user-attachments/assets/1baf4cf6-804d-4802-a674-1c71002b7c80" />

이처럼 브라우저는 `동기적`(synchronous)으로, **즉 위에서 아래 방향으로 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행한다. **
- 이것은 `script 태그`의 위치에 따라 HTML 파싱이 `블로킹`되어 **DOM 생성이 지연될 수 있다는 것을 의미한다. **
- 따라서 `script 태그`의 위치는 중요한 의미를 갖는다.


### ❌ 블로킹 케이스: script 태그가 body 상단에 위치

```
<!-- [예제 38-04] !-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <script>
      const $apple = document.getElementById('apple');
      $apple.style.color = 'red'; // TypeError: cannot read property 'style' of null
    </script>
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </body>
</html>
```

DOM API인 document.getElemntById('apple'은 DOM에서 idrk 'apple'인 HTML 요소를 취득한다.
하지만 documentGetElementById('apple')을 실해앟는 시점에는 아직 id가 'apple'인 HTML 요소를 파싱하지 않았기 때문에 id가 'apple'인 HTML 요소가 포함되어 있지 않은 상태다.

#### 따라서, body 요소 가장 아래에 자바스크립트를 위치시키기
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다.
- 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이리 로딩 시간이 단축된다.


<br>

### ✅ 해결 방안: script 태그를 body 요소 가장 아래로 이동

```
<!-- [예제 38-05] !-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      const $apple = document.getElementById('apple');
      $apple.style.color = 'red';
    </script>
  </body>
</html>
```


<br>

## 38.9 Script 태그의 async/defer 어트리뷰트

자바스크립트 파싱에 의한 DOM 생성이 중단(blocking)되는 문제를 근본적으로 해결하기 위해 HTML5부터 script 태그에 `async`와 `defer` 어트리뷰트가 추가되었다.
- `async`와 `defer` 어트리뷰트는 `src 어트리뷰트`를 통해 **외부 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다.**
- async와 defer 어트리뷰트를 사용하면 **HTML 파싱과 외부 자바스크립트 파일의 로드가 `비동기적`(asynchronous)으로 동시에 진행된다. ** (하지만 자바스크립트 실행 시점에 차이가 있다.)

```html
<!-- [예제 38-06] --!>
<script async src="extern.js"></script>
<script defer src="extern.js"></script>
```

<br>

### async 어트리뷰트
자바스크립트의 파싱과 실행은 자바스크립트 파일의 로드가 완료된 직후 진행되며, 이때 HTML 파싱이 중단된다.
- 여러 개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 먼저 실행되므로 **순서가 보장되지 않는다.**
  - 따라서 **순서 보장이 필요한 script 태그에는 `async 어트리뷰트`를 지정하지 않아야한다.**
<img width="800"  alt="38_14_script_태그의_async_어트리뷰트" src="https://github.com/user-attachments/assets/14fbbc16-d5a3-4aea-b25d-4e2328a39c4d" />




<br>

### defer 어트리뷰트
자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후(이때 `DOMContentLoaded` 이벤트가 발생한다) 진행된다.
- 따라서 **DOM 생성이 완료된 이후 실행되어야 할 자바스크립트에 유용하다.**

<img width="800" alt="38_15_script_태그의_defer_어트리뷰트" src="https://github.com/user-attachments/assets/019d7d9f-115e-4a9e-98fd-60a659a8b477" />







