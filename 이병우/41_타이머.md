# 41장 타이머

## 41.1 호출 스케줄링
- `호출 스케줄링`: 함수를 명시적으로 호출하지 않고, **일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약하기 위해 `타이머 함수`를 사용하는 것**
- 타이머 함수는 `호스트 객체`다.(ECMAScript 사양에 정의된 빌트인 함수가 아니라, `브라우저 환경` 혹은 `Node.js 환경`에서 제공하기 때문)
- 자바스크립트 엔진은 `싱글 스레드`(single thread)로 동작하지만, 타이머 함수(`setTimeout`,`setInterval`)은 `비동기 처리 방식`(asyncronous)으로 동작한다.


<br>

## 41.2 타이머 함수
### 41.2.1 setTimeout / clearTimeout
### 41.2.2 setInterval / clearInterval

(생략)

<br>

## 41.3 디바운스와 스로틀
`scroll`, `resize`, `input`, `mousemove` 같은 이벤트는 짧은 시간 간격으로 연속해서 발생한다. 이러한 이벤트에 바인딩한 이벤트 핸들러는 과도하게 호출되어 성능에 문제를 일으킬 수 있다.
- `디바운스`와 `스로틀`은 **짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다.**

<br>

### 41.3.1 디바운스(debounce)
`디바운스`(debounce)는 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 **일정 시간이 경과한 이후에 이벤트 핸들러가 한 번만 호출되도록 한다.**
- 즉, **디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.**

> ### ***디바운스 유래***
> - _원래 의미: ‘스프링이 달린 버튼이나 스위치를 누를 때 생기는 잡음을 제거한다’는 뜻에서 나왔음._
>   - _상황 예시: 기계식 버튼을 누르면, 물리적으로 접점이 튕기면서 순간적으로 여러 번 ON/OFF 신호가 발생한다._
>   - _이를 **바운싱**(bouncing)이라고 부름_
>     - _전기 신호가 한 번 눌렀는데 여러 번 들어오는 현상_
>   - _해결책: 전자회로에서는 **디바운서**(debouncer)라는 회로를 사용해서 “마지막 안정된 신호만 전달”하도록 했음_
> - _**프로그래밍으로 넘어온 이유**: 웹에서도 비슷한 상황이 있기 때문_
>     - _예) 사용자가 입력 필드에 타이핑할 때 이벤트가 너무 자주 발생하면 서버 요청이 낭비된다._
> - _**결론**: 그래서 “마지막 이벤트가 끝난 뒤 일정 시간 후에 실행”하도록 해서 중복 호출을 방지하는 방식이 디바운스라 하게 되었음_



```js
const debounce = (callback, delay) => {
  let timerId;
  return (...args) => {
    if (timerId) clearTimeout(timerId);
    timerId = setTimeout(callback, delay, ...args);
  };
};
```


<img width="800" alt="41_2_디바운스" src="https://github.com/user-attachments/assets/acac4857-5d23-4ec5-a919-48aaa73b2164" />


####👻 클로저 사용
```js
const debounce = (callback, delay) => {
  let timerId;
  // debounce 함수는 timerId를 기억하는 클로저를 반환한다.
  return (...args) => {
    // delay가 경과하기 이전에 이벤트가 발생하면 이전 타이머를 취소하고 새로운 타이머를 재설정한다.
    // 따라서 delay보다 짧은 간격으로 이벤트가 발생하면 callback은 호출되지 않는다.
    if (timerId) clearTimeout(timerId);
    timerId = setTimeout(callback, delay, ...args);
  };
};
```



#### ✨ 활용 사례
- resize 이벤트 처리
- input 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성 UI 구현
- 버튼 중복 클릭 방지 처리 등



<br>

### 41.3.2 스로틀(throttle)
`스로틀`(throttle)은 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 **일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다. **
- 즉, **스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 `호출 주기`를 만든다.**


> ### ***스로틀 유래***
> - _**원래 의미**: 엔진이나 밸브를 제어하는 **스로틀(throttle)**_
>   - _자동차나 오토바이에서 가속 페달로 연료 공급량을 조절하는 장치가 스로틀이다._
> - _**프로그래밍 의미**: 일정 시간 동안 이벤트를 한 번만 실행하게 제한하는 것_
>   - _예시: 스크롤 이벤트를 0.1초마다 한 번씩만 처리_
> - _**왜 이런 용어를 차용한 것일까**:_
>   - _실제 엔진에서 연료 흐름을 조절하는 것처럼, 이벤트 흐름을 **조절**(throttle)한다는 의미에서 사용한 것으로 추측_



```js
const throttle = (callback, delay) => {
  let timerId;
  return (...args) => {
    if (timerId) return;
    timerId = setTimeout(() => {
      callback(...args);
      timerId = null;
    }, delay);
  };
};
```



<img width="800"  alt="41_3_스로틀" src="https://github.com/user-attachments/assets/3cfe844b-3b48-4037-952d-6f9e2d21436b" />


#### 👻 클로저 사용
```js
const throttle = (callback, delay) => {
  let timerId;
  // throttle 함수는 timerId를 기억하는 클로저를 반환한다.
  return (...args) => {
    // delay가 경과하기 이전에 이벤트가 발생하면 아무것도 하지 않다가
    // delay가 경과했을 때 이벤트가 발생하면 새로운 타이머를 재설정한다.
    // 따라서 delay 간격으로 callback이 호출된다.
    if (timerId) return;
    timerId = setTimeout(() => {
      callback(...args);
      timerId = null;
    }, delay);
  };
};
```




#### ✨ 활용 사례
- scroll 이벤트 처리
- 무한 스크롤 UI 구현 (infinite scrolling) 등

