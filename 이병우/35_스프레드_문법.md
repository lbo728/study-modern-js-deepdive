# 35장 스프레드 문법
ES6에서 도입된 `스프레드 문법`(spread syntac, 전개 문법) `...`은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 (전개, 분산하여, spread) 개별적인 값들의 목록으로 만든다.
- 대상: `Array`, `String`, `Map`, `Set`, `DOM 컬렉션`(`NodeList`, `HTMLCollection`), `arguments`
  - (즉, `for ... of` 문으로 순회할 수 있는 이터러블에 한정된다.)

```js
// [예제 35-01]
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3).
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(... 'Hello'); // H e l l o

// Map과 Set은 이터러블이다.
console.log(... new Map[['a', '1'], ['b', '2']])); // ['a', '1'] ['b', '2']
console.log(... new Set[[1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(... { a: 1, b: 2 });
// TypeError: Found non-callable @@iterator
```

### 스프레드 문법의 결과는 변수에 할당할 수 없다.
위 예제에서 ...[1, 2, 3]은 이터러블인 배열을 펼쳐서 요소들을 개별적인 값들의 목록 1 2 3으로 만든다.
- 이때 1 2 3은 `값`이 아니라 값들의 "**`목록`**"이다.
- 따라서 스프레드 문법의 결과는 **변수에 할당할 수 없다.**

```js
// 스프레드 문법의 결과는 값이 아니다.
const list = ...[1,2,3]; // SyntaxError: Unexpected token ...
```

스프레드 문법의 결과물은 다음과 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.
- **함수 호출문의 인수 목록**
  - ```js
    function sum(a, b, c) {
      return a + b + c;
    }
    
    const numbers = [1, 2, 3];
    
    // 스프레드 문법으로 배열을 개별 인수로 전달
    console.log(sum(...numbers)); // 6
    ```
- **배열 리터럴의 요소 목록**
  - ```js
    const arr1 = [1, 2];
    const arr2 = [3, 4];
    
    // 기존 배열을 전개하여 새로운 배열 생성
    const merged = [...arr1, ...arr2];
    console.log(merged); // [1, 2, 3, 4]
    ```   
- **객체 리터럴의 프로퍼티 목록**
  - ```js
    const obj1 = { x: 1, y: 2 };
    const obj2 = { y: 10, z: 3 };
    
    // 객체를 전개하여 새로운 객체 생성
    const combined = { ...obj1, ...obj2 };
    console.log(combined); // { x: 1, y: 10, z: 3 }
    ```   

