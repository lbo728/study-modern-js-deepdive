# 35장 스프레드 문법
ES6에서 도입된 `스프레드 문법`(spread syntax, 전개 문법) `...`은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 (전개, 분산하여, spread) 개별적인 값들의 목록으로 만든다.
- 대상: `Array`, `String`, `Map`, `Set`, `DOM 컬렉션`(`NodeList`, `HTMLCollection`), `arguments`
  - (즉, `for ... of` 문으로 순회할 수 있는 이터러블에 한정된다.)

- [_MDN 참고: 스프레드 문법(spread syntax, 전개 문법)_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

```js
// [예제 35-01]
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3).
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(... 'Hello'); // H e l l o

// Map과 Set은 이터러블이다.
console.log(... new Map[['a', '1'], ['b', '2']])); // ['a', '1'] ['b', '2']
console.log(... new Set[[1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(... { a: 1, b: 2 });
// TypeError: Found non-callable @@iterator
```

<br>

### 스프레드 문법의 결과는 변수에 할당할 수 없다.
위 예제에서 ...[1, 2, 3]은 이터러블인 배열을 펼쳐서 요소들을 개별적인 값들의 목록 1 2 3으로 만든다.
- 이때 1 2 3은 `값`이 아니라 값들의 "**`목록`**"이다.
- 따라서 스프레드 문법의 결과는 **변수에 할당할 수 없다.**

```js
// 스프레드 문법의 결과는 값이 아니다.
const list = ...[1,2,3]; // SyntaxError: Unexpected token ...
```

스프레드 문법의 결과물은 다음과 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.
- **함수 호출문의 인수 목록**
  - ```js
    function sum(a, b, c) {
      return a + b + c;
    }
    
    const numbers = [1, 2, 3];
    
    // 스프레드 문법으로 배열을 개별 인수로 전달
    console.log(sum(...numbers)); // 6
    ```
- **배열 리터럴의 요소 목록**
  - ```js
    const arr1 = [1, 2];
    const arr2 = [3, 4];
    
    // 기존 배열을 전개하여 새로운 배열 생성
    const merged = [...arr1, ...arr2];
    console.log(merged); // [1, 2, 3, 4]
    ```   
- **객체 리터럴의 프로퍼티 목록**
  - ```js
    const obj1 = { x: 1, y: 2 };
    const obj2 = { y: 10, z: 3 };
    
    // 객체를 전개하여 새로운 객체 생성
    const combined = { ...obj1, ...obj2 };
    console.log(combined); // { x: 1, y: 10, z: 3 }
    ```   

<br>

## 35.1 함수 호출문의 인수 목록에서 사용하는 경우

### 예시 01: Max.max

```js
// [예제 36-03]
const arr = [1, 2, 3]

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
const max = Math.max(arr); // → NaN
```

Math.max 메서드는 매개변수 개수를 확정할 수 없는 `가변 인자 함수`다.

```js
// [예제 36-04]
Math.max(1);         //  → 1
Math.max(1,2);       //  → 2
Math.max(1,2,3);     //  → 3
Math.max();          //  → -Infinity
```
Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할 수 없으므로 `NaN`을 반환한다.


```js
// [예제 36-05]
Math.max([1, 2, 3]);         //  → NaN
```

이러한 문제를 해결하기 위해 **배열을 펼쳐서 요소들을 개별적인 값들의 목록으로 만든 후, Math.max 메서드의 인수로 전달**해야 한다.


#### 해결 01: Function.prototype.appply (스프레드 문법 사용 이전)
```js
// [예제 36-06]
var arr = [1, 2, 3];

// apply 함수의 2번째 인수(배열)는 apply 함수가 호출하는 함수의 인수 목록이다.
// 따라서 배열이 펼쳐져서 인수로 전달되는 효과가 있다.
var max = Math.max.apply(null, arr); //  → 3
```

<br>

#### ✅ 해결 02: 스프레드 문법 사용
```js
// [예제 36-07]
var arr = [1, 2, 3];

// 스프레드 문법을 사용하여 배열 arr을 1, 2, 3으로 펼쳐서 Math.max에 전달한다.
// Math.max(...[1,2,3])은 Math.max(1,2,3)과 같다.
var max = Math.max.(...arr); //  → 3
```



<br>

### ⚠️ Rest 파라미터와의 차이
**`스프레드 문법`은 [Rest 파라미터](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters)와 형태가 동일하여 혼동할 수 있으므로 주의할 필요가 있다.**
> #### Rest 파라미터
> 함수에 전달된 인수들의 목록을 "**배열**"로 전달받기 위해 매개변수 이름 앞에 `...`을 붙인다.

- `스프레드 문법`은 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 `이터러블`을 펼쳐서 **개별적인 값들의 목록을 만드는 것이다.**
- 즉, `Rest 파라미터`와 스프레드 문법은 **서로 반대의 개념이다.**

```js
// [예제 35-08]
// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.
function foo(...rest) {
  console.log(rest); // 1, 2, 3  → [1, 2, 3]
}

// 스프레드 무넙은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.
// [1, 2, 3] → 1, 2, 3
foo(...[1, 2, 3]);
```


<br>

## 35.2 배열 리터럴 내부에서 사용하는 경우
ES5에서 사용하던 기존의 방식과 비교하기.


### 35.2.1 concat
> #### _Array.prototype.concat()_
> _Array 인스턴스의 `concat()` 메서드는 두 개 이상의 배열을 병합하는 데 사용됩니다. 이 메서드는 기존 배열을 변경하지 않고, 새 배열을 반환합니다._
> - [참고: _Array.prototype.concat() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)

> #### _Concat의 사전적 정의_
>  "**concatenate**"의 줄임말
>  concatenate [kɑnkǽtənèit]
>  1. 사슬같이 잇다; 연쇄시키다; <사건 등을> 결부[연결]시키다, 연관시키다
>  2. 연쇄된, 이어진, 연결된

#### 🟠 ES5
```js
// [예제 35-09]
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]
```



<br>

스프레드 문법을 사용하면 별도의 메서드를 사용하지 않고 배열 리터럴만으로 **2개의 배열을 1개의 배열로 결합할 수 있다.**

#### ✅ ES6(스프레드 문법)


```js
// [예제 35-10]
var arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]
```


<br>


### 35.2.2 splice
ES5에서 어떤 배열의 중간에 다른 배열의 요소들을 추가하거나 제거하려면 `splice 메서드`를 사용한다.
- 이때 splice 메서드의 **세 번째 인수로 배열을 전달하면 배열 자체가 추가된다.**

> #### _Array.prototype.splice()_
> _`splice()` 메서드는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다._
> - [참고: _Array.prototype.splice() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)

> #### _splice 사전적 정의_
> _미국∙영국 [splaɪs]_
> _1. (밧줄의 두 끝을 함께 꼬아서) 잇다_ 
> _2. (필름·테이프 등의 두 끝을) 붙이다[잇다]_ 


<br>

####  ❌ ES5: splice만 사용한 경우 실패 
```js
// [예제 35-11]

var arr1 = [1, 4];
var arr2 = [2, 3];

// 세 번째 인수 arr2을 해체하여 전달해야 한다.
// 그렇지 않으면 arr1에 arr2 배열 자체가 추가된다.
arr1.splice(1, 0, arr2);

// 기대한 결과는 [1, [2, 3], 4]가 아니라 [1, 2, 3, 4]다.
console.log(arr1); // [1, [2, 3], 4]
```

####  🟠 ES5: Function.prototype.apply을 slice와 함께 사용하여 기대값 충족
```js
// [예제 35-12]

var arr1 = [1, 4];
var arr2 = [2, 3];

/*
1. apply 메서드의 2번째 인수(배열)는 apply 메서드가 호출한 splice 메서드의 인수 목록이다.
2. apply 메서드의 2번째 인수 [1, 0].concat(arr2)는 [1, 0, 2, 3]으로 평가된다.
3. 따라서, splice 메서드에 apply 메서드의 2번째 인수 [1, 0, 2, 3]이 해체되어 전달된다.
4. 즉, arr1[1]로부터 0개의 요소를 제거하고 그 자리(arr1[1])에 새로운 요소(2, 3)을 삽입한다.
*/
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));

// 기대한 결과는 [1, [2, 3], 4]가 아니라 [1, 2, 3, 4]다.
console.log(arr1); // [1, [2, 3], 4]
```



> #### _Function.prototype.apply()_
> _`apply()` 메서드는 주어진 this 값과 배열 (또는 유사 배열 객체) 로 제공되는 `arguments` 로 함수를 호출합니다._
> -  _⚠️ 이 함수의 구문은 거의 `call()` 구문과 유사합니다. 근본적인 차이점은 `call()` 은 **함수에 전달될 인수 리스트를 받는데** 비해, apply() 는 **인수들의 단일 배열을 받는다는 점**입니다._
> - [참고: Function.prototype.apply() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)

> #### _Function.prototype.call()_
> _`call() 메소드는 주어진 this 값 및 각각 전달된 인수와 함께 함수를 호출합니다._
> - [참고: _Function.prototype.call() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call)

> #### _Function.prototype.bind()_
> _`bind()` 메소드가 호출되면 새로운 함수를 생성합니다. 받게되는 첫 인자의 value로는 this 키워드를 설정하고, 이어지는 인자들은 바인드된 함수의 인수에 제공됩니다._
> - [참고: _Function.prototype.bind() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)


<br>

스프레드 문법을 사용하면 훨씬 간결하게 표현 가능

#### ✅ ES6(스프레드 문법)

```js
// [예제 35-13]

var arr1 = [1, 4];
var arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4]
```


<br>

### 35.2.3 배열 복사 (slice)
ES5에서 배열을 복사하려면 `slice 메서드`를 사용한다. (얕은 복사, shallow copy)

> #### _Array.prototype.slice()_
> _`slice()` 메서드는 어떤 배열의 begin 부터 end 까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 바뀌지 않습니다._
> - [참고: Array.prototype.slice() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)

> #### _slice라는 이름을 붙인 유래_
> _slice는 칼로 빵을 자르듯이 배열에서 원하는 구간(begin~end)을 잘라내서 새 배열로 반환한다는 개념에서 온 이름._
> _"복사"는 결과 동작의 한 부분일 뿐이고, 핵심 개념은 원본에서 잘라낸 부분을 가져온다는 것_
>
> _by ChatGPT_


#### 🟠 ES5: splice만 사용한 경우 실패 
```js
// [예제 35-14]

var origin = [1, 2];
var copy = origin.slice();

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

스프레드 문법을 사용하면 훨씬 간결하게 표현 가능

#### ✅ ES6(스프레드 문법)

```js
// [예제 35-15]

var origin = [1, 2];
var copy = [...origin];

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

slice와 마찬가지로 **얕은 복사**를 수행(shallow copy)

<br>


### 35.2.4 이터러블을 배열로 변환

ES5에서 `이터러블`을 배열로 반환하려면 `Function.prototype.apply` 또는 `Function.prototype.call` 메서드를 사용하여 `slice` 메서드를 호출해야한다.

#### 🟠 ES5: Function.prototype.call + Array.prototype.slice
```js
// [예제 35-16]

function sum() {
  // 이터러블이면서 유사 배열 객체인 `arguments`를 배열로 변환
  var args = Array.prototype.slice.call(arguments);

  return args.reduce(function (pre, cur) {
    return pre + cur;
  }, 0 );
}

console.log(sum(1, 2, 3)); // 6
```
> #### _arguments 객체_
> _`arguments 객체`는 함수에 전달된 인수에 해당하는 `Array 형태`의 객체입니다._
>
> _⚠️ "**Array 형태**"란 `arguments`가 length 속성과 더불어 0부터 인덱스 된 다른 속성을 가지고 있지만, Array의 forEach, map과 같은 내장 메서드를 가지고 있지 않다는 뜻입니다._(책에서 표현하는 "유사 배열 객체"와 동의어, `array-like object`)
> - [참고: arguments 객체 | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments)

| 구분 | ES5 (옛날) | ES6 이후 (최신) |
| --- | --- | --- |
| **자료 구조** | 유사 배열 객체 (Array-like Object) | 유사 배열 객체 (Array-like Object) |
| **이터러블 여부** | ❌ 이터러블 아님 → `for...of` 불가 | ✅ `Symbol.iterator` 구현됨 → `for...of` 가능 |
| **프로토타입** | `Object.prototype` 상속 | `Object.prototype` 상속 |
| **배열 메서드 사용 가능 여부** | ❌ 없음 (`map`, `forEach` 바로 못 씀) | ❌ 여전히 없음 (`map`, `forEach`는 직접 호출해야 함) |
| **배열로 변환 방법** | `Array.prototype.slice.call(arguments)` | `Array.from(arguments)` 또는 `[...arguments]` |
| **MDN "Array 형태" 의미** | 인덱스와 length는 있지만, 배열 메서드 없음 | 동일 의미 — 여전히 배열 메서드는 없음 |


<br>

> #### _Array.prototype.reduce()_
> _reduce() 메서드는 배열의 각 요소에 대해 주어진 리듀서 (reducer) 함수를 실행하고, 하나의 결과값을 반환합니다._
> - [참고: Array.prototype.reduce() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)



```js
// [예제 35-17]
// 이터러블이 아닌 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3
}

const arr = Array.prototype.slice.call(arrayLike); // → [1, 2, 3]
console.log(Array.isArray(arr)); // true
```


> #### _Array.isArray()_
> `_Array.isArray()` 정적 메서드는 전달된 값이 Array인지 판단합니다._
> - [참고: Array.isArray() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)

<br>

#### ✅ ES6(스프레드 문법)
스프레드 문법을 사용하면 훨씬 간편하게 이터러블을 배열로 변환할 수 있다. 
- `arguments 객체`는 이터러블이면서 유사 배열 객체이기 때문에 스프레드 문법의 대상이 될 수 있다.

```js
// [예제 35-18]
function sum() {
    // 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```




#### ✅✅ ES6(Rest 파라미터)

```js
// [예제 35-19]
// Rest 파라미터 args는 함수에 전달돈 인수들의 목록을 배열로 전달받는다.
const sum = (...args) => args.reduce((pre, cur) => pre + cur, 0);

console.log(sum(1, 2, 3)); // 6
```

<br>

### ⚠️ 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.
```js
// [예제 35-20]
// 이터러블이 아닌 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3
}

const arr = [...arrayLike];
// TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))
```

<br>

### ✅ 이터러블이 아닌 유사 배열 객체를 배열로 변경하는 방법: Array.from
```js
// [예제 35-21]
// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다.
Array.from(arrayLike); // → [1, 2, 3]
```

<br>

> #### _Array.from()_
> _`Array.from()` 정적 메서드는 **순회 가능 또는 유사 배열 객체**에서 얕게 복사된 새로운 Array 인스턴스를 생성합니다._
> - [참고: Array.from() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from)


<br>

## 35.3 객체 리터럴 내부에서 사용하는 경우

`Rest 프로퍼티`와 함께 2021년 1월 현재 TC39 프로세스의 stage 4(Finished) 단계에 제안되어 있는 `스프레드 프로퍼티`를 사용하면 **객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다.**
- `스프레드 프로퍼티` 제안은 이터러블이 아닌, **일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다.**

### ✅ 스프레드 프로퍼티 사용
```js
// [예제 35-22]
// 스프레드 프로퍼티
// 객체 복사(얕은 복사)
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2 }

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4} };
console.log(merged) // { x: 1, y: 2, a: 3, b: 4 }
```

### 🟠 스프레드 프로퍼티 이전: ES6에 도입된 Object.assign 메서드 사용
```js
// [예제 35-23]
// 객체 병합. 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = Object.assign({}, { x: 1, y: 2}, { y: 10, z: 3});
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = Object.assign({}, { x: 1, y: 2 }, { y: 100 });
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = Object.assign({}, { x: 1, y: 2 }, { z: 0 });
console.log(added); // { x: 1, y: 2, z: 0 }
```

> #### _Object.assign()_
> _`Object.assign()` 메서드는 출처 객체들의 모든 열거 가능한 자체 속성을 복사해 대상 객체에 붙여넣습니다. 그 후 대상 객체를 반환합니다._
> - [참고: Object.assign() | MDN_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)



### ✅✅ 스프레드 프로퍼티는 Object.assign 메세드를 대체할 수 있다.
```js
// [예제 35-24]
// 객체 병합. 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
// changed = { ...{ x: 1, y: 2 }, ...{ y: 100 } };
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, y: 2 }, z: 0 };
// added = { ...{ x: 1, y: 2 }, ...{ z: 0 } };
console.log(added); // { x: 1, y: 2, z: 0 }
```

<br>
## BONUS.스프레드 문법을 알야아 하는 이유
<br>
## BONUS.실무 사례




